# SEEDlabs: Format-String Vulnerability Lab

#### Ozgur Ural
#### Student ID: 2564455

## Lab Description

The learning objective of this lab is for students to gain the first-hand experience on format-string vulnerability by putting what they have learned about the vulnerability from class into actions. The format-string vulnerability is caused by code like printf(user_input), where the contents of variable of user_input is provided by users. When this program is running with privileges (e.g., Set-UIDprogram), this printf statement becomes dangerous, because it can lead to one of the following consequences: (1) crash the program, (2) read from an arbitrary memory place, and (3) modify the values of in an arbitrary memory place. The last consequence is very dangerous because it can allow users to modify internal variables of a privileged program, and thus change the behavior of the program. 

In this lab, students will be given a program with a format-string vulnerability; their task is to develop a scheme to exploit the vulnerability. In addition to the attacks, students will be guided to  walk  through  a  protection  scheme  that  can  be  used  to  defeat  this  type  of  attacks.  Students need to evaluate whether the scheme work or not and explain why. 

It  should  be  noted  that  the  outcome  of  this  lab  is  operating  system  dependent.  Our description  and  discussion  are  based  on  Ubuntu  Linux.  It  should  also  work  in  the  most  recent version of Ubuntu. However, if you use different operating systems, different problems and issues might come up.

## Lab Tips
You can use the command line to convert between hex and decimal:
*hex to dec: echo $((16#894f00c)), here 894f00c is a sample hex value.
*dec to hex: echo ‘ibase=10;obase=16;123’ | bc, here 123 a sample decimal value


## Lab Tasks - Exploit the Vulnerability
The provided vul_prog.c is a format-string vulnerable program. In the following program, you will be asked to provide an input, which will be saved in a buffer called user_input. The program then prints  out  the  buffer  using  printf.  The  program  needs  to  be  compiled  and  made  as  a  Set-UIDprogram  (using  the  root  account),  i.e.,  it  runs  with  the  root  privilege.  Unfortunately,  there  is  a format-string vulnerability in the way how the printf is called on the user inputs. We want to exploit this vulnerability and see how much damage we can achieve. The program has two secret values stored in its memory, and you are interested in these secret values. However, the secret values are unknown to you, nor can you find them from reading the  binary  code  (for  the  sake  of  simplicity,  we  hardcode  the  secrets  using  constants  0x44  and 0x55). Although you do not know the secret values, in practice, it is not so difficult to find out the memory  address  (the  range  or  the  exact  value)  of  them  (they  are  in  consecutive  addresses), because for many operating systems, the addresses are exactly the same anytime you run the program.  In  this  lab,  we  just  assume  that  you  have  already  known  the  exact  addresses.  To achieve this, the program “intentionally” prints out the addresses for you. With such knowledge, your goal is to achieve the followings (not necessarily at the same time):Crash the program.Print out the secret[1] value.Modify the secret[1] value.

Modify the secret[1] value to a pre-determined value (0x50). [Hint: think about %n]Note that the binary code of the program (Set-UID) is only readable/executable by you, and there is no way you can modify the code. Namely, you need to achieve the above objectives without modifying the vulnerable code. However, you do have a copy of the source code, which can help you design your attacks.Hints: From the printout, you will find out that secret[0] and secret[1] are located on the heap, i.e., the actual secrets are stored on the heap. We also know that the address of the first secret (i.e., the  value  of  the  variable  secret)  can  be  found  on  the  stack,  because  the  variable  secret  is allocated on the stack. In other words, if you want to overwrite secret[0], its address is already on the stack; your format string can take advantage of this information. However, although secret[1]is just right after secret[0], its address is not available on the stack. This poses a major challenge for your format-string exploit, which needs to have the exact address right on the stack in order to read or write to that address. 

