## 1 Lab Description
The learning objective of this lab is for students to gain the first-hand experience on the race-condition 
vulnerability by putting what they have learned about the vulnerability from class into actions. A race 
condition occurs when multiple processes access and manipulate the same data concurrently, and the 
outcome of the execution depends on the particular order in which the access takes place. If a privileged 
program has a race-condition vulnerability, attackers can run a parallel process to “race” against the 
privileged program, with an intention to change the behaviors of the program.
In this lab, students will be given a program with a race-condition vulnerability; their task is to develop a 
scheme to exploit the vulnerability and gain the root privilege. In addition to the attacks, students will be 
guided to walk through several protection schemes that can be used to counter the race-condition 
attacks. Students need to evaluate whether the schemes work or not and explain why.
## 2 Lab Tasks
Before working on the lab tasks, ensure to have read the Guidelines in Section 3.
### 2.1 Initial setup
Ubuntu 10.10 and later come in with a built-in protection against race condition attacks. This scheme 
works by restricting who can follow a symlink. According to the documen-tation, “symlinks in world-
writable sticky directories (e.g. /tmp) cannot be followed if the follower and directory owner do not match 
the symlink owner.” In this lab, we need to disable this protection. You can achieve that using the 
following command:

```sh
$ sudo sysctl -w fs.protected_symlinks=0
```

### 2.2 A Vulnerable Program
The following program is a seemingly harmless program. It contains a race-condition vulnerability.

```sh
/* vulp.c */
#include <stdio.h>
#include <unistd.h>
int main()
{ 
  char *fn = "/tmp/XYZ";
  char buffer[60];FILE *fp;
  /* get user input */
  scanf("%50s", buffer );
  if (!access(fn, W_OK))
  {
    fp = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp);
    fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp);
  }
  else printf("No permission \n");
}
```
In this lab, you need to compile the above program using the root account and make it as a set-uid 
program. This program appends a string of user input to the end of a temporary file /tmp/XYZ. Since the 
code runs with the root privilege, it carefully checks whether the real user actually has the access 
permission to the file /tmp/XYZ; that is the purpose of the access() call. Once the program has made sure 
that the real user indeed has the right, the program opens the file and writes the user input into the file. In 
this lab, you can use the seed account to create a file named XYZ.

It appears that the program does not have any problem at a first glance. However, there is a race 
condition vulnerability in this program: due to the window (the simulated delay) between the check 
(access) and the use (fopen), there is a possibility that the file used by access is different from the file 
used by fopen, even though they have the same file name /tmp/XYZ. If a malicious attacker can 
somehow make /tmp/XYZ a symbolic link pointing to /etc/shadow, the attacker can cause the user input 
to be appended to /etc/shadow (note that the program runs with the root privilege, and can therefore 
overwrite any file).

### 2.3 Task 1: Exploit the Race Condition Vulnerabilities
You need to exploit the race condition vulnerability in the above Set-UID program. More specifically, you 
need to add a line “cs532-lab” to the end of /etc/shadow by using the race. Please also explain why your 
attack can success.
Actually, if you are able to modify the shadow file, you can use the same attack to modify the /etc/passwd 
file. As a result, you are be able to create any kind of accounts for the OS.
### 2.4 Task 2: Protection Mechanism A: Repeating
Getting rid of race conditions is not easy, because the check-and-use pattern is often necessary in 
programs. Instead of removing race conditions, we can actually add more race conditions, such that to 
compromise the security of the program, attackers need to win all these race conditions. If these race 
conditions are designed properly, we can exponentially reduce the winning probability for attackers. The 
basic idea is to repeat access() and fopen() for several times.
Please use this strategy to modify the vulnerable program and repeat your attack. Report how difficult it is 
to succeed, if you can still succeed.
### 2.5 Task 3: Protection Mechanism B: Principle of Least Privilege
The fundamental problem of the vulnerable program in this lab is the violation of the Principle of Least 
Privilege. The programmer does understand that the user who runs the program might be too powerful, 
so he/she introduced access() to limit the user’s power. However, this is not the proper approach. A better
approach is to apply the Principle of Least Privilege; namely, if users do not need certain privilege, the 
privilege needs to be disabled.
We can use seteuid() system call to temporarily disable the root privilege, and later enable it if necessary. 
Please use this approach to fix the vulnerability in the program, and then repeat your attack. Will you be 
able to succeed? Please report your observations and explanation.
### 2.6 Task 4: Protection Mechanism C: Ubuntu’s Built-in Scheme
As we mentioned in the initial setup, comes with a built-in protection scheme against race condition 
attacks.
In this task, you need to turn the protection back on using the following command:
```sh
$ sudo sysctl -w fs.protected_symlinks=1
```
In your report, please describe your observations. Please also explain why does this protection scheme 
work?
